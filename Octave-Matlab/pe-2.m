# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


global SQUARE_ROOT_OF_FIVE = sqrt(5);

# Formula of Moivre-Binet. Add 1 because of the index-shift in the statement of the problem
function Fibonacci = Fibonacci(n)
	global SQUARE_ROOT_OF_FIVE
	Fibonacci = (1/SQUARE_ROOT_OF_FIVE) * ( ((1+ SQUARE_ROOT_OF_FIVE)/2).^(n+1) - ((1- SQUARE_ROOT_OF_FIVE)/2).^(n+1) );
endfunction




function sum = pe2(below)
	sum = 0;
	step = 2;
	f_nPlus = 2;
	while (f_nPlus < below)
		sum +=f_nPlus;
		step += 3;
		f_nPlus = Fibonacci(step);
	endwhile
endfunction

result1 = pe2(8)
result2 = pe2(9)

format long
tic
result3 = pe2(4*10^6)
toc

fprintf("%s\n", "")





# Another implementation using matrix operation:
# we calculate all the Fibonacci numbers that we need with the help of a vector.
# For this we use again the formula of Moivre-Binet.

function returnValue = pe21(m)
	global SQUARE_ROOT_OF_FIVE
	# We need to determine the length of that vector. We are using the fact that in the formula of Moivre-Binet the second term is negligible.
	# Therefore we can say:
	# m >= 1/SQUARE_ROOT_OF_FIVE * ((1+ SQUARE_ROOT_OF_FIVE)/2).^(n+1)
	# Where m is the number below we want to find the n-th Fibonacci-number.
	# Solving this for n leads to:
	n = floor(log(SQUARE_ROOT_OF_FIVE*m) / log((1+SQUARE_ROOT_OF_FIVE)/2)) - 1;

	# Only the even Fibonacci numbers are needed. Thus we start with the second and increase by 3 (as only every third Fibonacci-number is even).
	y=[ 2 : 3 : n];

	format long
	returnValue = sum(Fibonacci(y));
endfunction


result4 = pe21(8)
result5 = pe21(9)

tic
result6 = pe21(4*10^6)
toc
# The second implementation seems to be faster.